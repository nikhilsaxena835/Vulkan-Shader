#version 450
layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0) buffer InputImage {
    uint pixels[];
} inputImage;

layout(binding = 1) buffer OutputImage {
    uint pixels[];
} outputImage;

layout(binding = 2) buffer MaskImage {
    uint pixels[];
} maskImage;

layout(push_constant) uniform PushConstants {
    int width;
    int height;
} pushConstants;

// Unpack 32-bit pixel to vec4 (RGBA)
vec4 unpackPixel(uint pixel) {
    return vec4(
        float((pixel >> 0)  & 0xFF) / 255.0,
        float((pixel >> 8)  & 0xFF) / 255.0,
        float((pixel >> 16) & 0xFF) / 255.0,
        float((pixel >> 24) & 0xFF) / 255.0
    );
}

// Pack vec4 (RGBA) into 32-bit pixel
uint packPixel(vec4 color) {
    uint r = uint(clamp(color.r, 0.0, 1.0) * 255.0);
    uint g = uint(clamp(color.g, 0.0, 1.0) * 255.0);
    uint b = uint(clamp(color.b, 0.0, 1.0) * 255.0);
    uint a = uint(clamp(color.a, 0.0, 1.0) * 255.0);
    return (a << 24) | (b << 16) | (g << 8) | r;
}

vec4 getColor(int x, int y) {
    x = clamp(x, 0, pushConstants.width - 1);
    y = clamp(y, 0, pushConstants.height - 1);
    return unpackPixel(inputImage.pixels[y * pushConstants.width + x]);
}

float getMaskValue(int x, int y) {
    x = clamp(x, 0, pushConstants.width - 1);
    y = clamp(y, 0, pushConstants.height - 1);
    uint pixel = maskImage.pixels[y * pushConstants.width + x];
    return float((pixel >> 24) & 0xFF) / 255.0; // alpha
}

float colorSimilarity(vec3 a, vec3 b) {
    return 1.0 - (abs(a.r - b.r) + abs(a.g - b.g) + abs(a.b - b.b)) / 3.0;
}

vec3 enhanceGhibliColor(vec3 color) {
    float luminance = dot(color, vec3(0.299, 0.587, 0.114));
    vec3 saturated = mix(vec3(luminance), color, 1.3);
    vec3 adjusted = saturated * 1.2;

    if (color.b > color.r && color.b > color.g) {
        adjusted.b *= 1.05;
    } else if (color.r > 0.5 && color.g > 0.5 && color.b < 0.5) {
        adjusted.r *= 1.1;
        adjusted.g *= 1.05;
    } else if (color.g > color.r && color.g > color.b) {
        adjusted.g *= 1.1;
    }
    return clamp(adjusted, 0.0, 1.0);
}

vec3 applyRegionColor(uint x, uint y) {
    vec4 center = getColor(int(x), int(y));
    const int radius = 3;
    const float threshold = 0.95;

    vec3 sum = vec3(0.0);
    float weightTotal = 0.0;

    for (int dy = -radius; dy <= radius; dy++) {
        for (int dx = -radius; dx <= radius; dx++) {
            vec4 neighbor = getColor(int(x) + dx, int(y) + dy);
            float sim = colorSimilarity(center.rgb, neighbor.rgb);

            if (sim > threshold) {
                float dist = length(vec2(dx, dy));
                float weight = max(0.0, radius - dist) / radius;
                sum += neighbor.rgb * weight;
                weightTotal += weight;
            }
        }
    }

    vec3 avg = (weightTotal > 0.0) ? (sum / weightTotal) : center.rgb;
    return enhanceGhibliColor(avg);
}

vec3 quantize(vec3 color, int levels) {
    return floor(color * float(levels)) / float(levels);
}

float paperTexture(vec2 uv) {
    float noise = fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);
    return noise * 0.02 - 0.01;
}

void main() {
    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;

    if (x >= uint(pushConstants.width) || y >= uint(pushConstants.height))
        return;

    uint idx = y * pushConstants.width + x;
    vec4 original = unpackPixel(inputImage.pixels[idx]);
    float maskVal = getMaskValue(int(x), int(y));

    if (maskVal > 0.5) {
        // Stylize the entire person region
        vec3 region = applyRegionColor(x, y);
        vec3 cel = quantize(region, 4);
        vec2 uv = vec2(float(x) / float(pushConstants.width), float(y) / float(pushConstants.height));
        vec3 final = cel + paperTexture(uv);
        outputImage.pixels[idx] = packPixel(vec4(final, original.a));
    } else {
        // Grayscale for background
        float gray = dot(original.rgb, vec3(0.299, 0.587, 0.114));
        outputImage.pixels[idx] = packPixel(vec4(vec3(gray), original.a));
    }
}